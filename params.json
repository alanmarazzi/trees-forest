{
  "name": "Don't get lost in a forest",
  "tagline": "Reference repo for \"Don't get lost in a forest\" post",
  "body": "# Don't get lost in a forest\r\n\r\nReference for \"Don't get lost in a forest\" post on [rdisorder.eu](http://rdisorder.eu)\r\n\r\nThis will be an intro to tree-based models in R.\r\n\r\n## Work in progress\r\n\r\nThe project will be ready by the end of 2016\r\n&nbsp;\r\n&nbsp;\r\n\r\n### In the meantime you can get a look at the brief intro below\r\n\r\n&nbsp;\r\n\r\nFast & brief primer on dplyr + intubate\r\n=======================================\r\n\r\nThis is a short intro to `dplyr` and `intubate` packages. I didn't want to load too much the **Don't get lost in a forest post** this intro is referring to.\r\n\r\nWhy dplyr and not base R?\r\n-------------------------\r\n\r\nWith `dplyr` we can avoid the creation of temporary datasets saving computation time and memory. It might look trivial, but you'll realize this approach not only will save a ton of time in the long-run, but it will also improve code clarity and simplicity.\r\n\r\n``` r\r\nlibrary(dplyr)\r\n```\r\n\r\n    ## \r\n    ## Attaching package: 'dplyr'\r\n\r\n    ## The following objects are masked from 'package:stats':\r\n    ## \r\n    ##     filter, lag\r\n\r\n    ## The following objects are masked from 'package:base':\r\n    ## \r\n    ##     intersect, setdiff, setequal, union\r\n\r\n``` r\r\nhead(iris)\r\n```\r\n\r\n    ##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\r\n    ## 1          5.1         3.5          1.4         0.2  setosa\r\n    ## 2          4.9         3.0          1.4         0.2  setosa\r\n    ## 3          4.7         3.2          1.3         0.2  setosa\r\n    ## 4          4.6         3.1          1.5         0.2  setosa\r\n    ## 5          5.0         3.6          1.4         0.2  setosa\r\n    ## 6          5.4         3.9          1.7         0.4  setosa\r\n\r\nNow let's say I want to see the mean of every species, how would I do?\r\n\r\n``` r\r\ntapply(iris$Petal.Width, iris[,5], mean)\r\n```\r\n\r\n    ##     setosa versicolor  virginica \r\n    ##      0.246      1.326      2.026\r\n\r\nThis is a very nice *one-liner* and for basic stuff like this is actually the best way to deal with grouping. But what if I want the mean of every variable at the same time?\r\n\r\n``` r\r\niris %>% # Take iris data set\r\n    group_by(Species) %>% # group everything by Species\r\n    summarize_each(funs(mean)) # summarize each group with the funs I want\r\n```\r\n\r\n    ## # A tibble: 3 × 5\r\n    ##      Species Sepal.Length Sepal.Width Petal.Length Petal.Width\r\n    ##       <fctr>        <dbl>       <dbl>        <dbl>       <dbl>\r\n    ## 1     setosa        5.006       3.428        1.462       0.246\r\n    ## 2 versicolor        5.936       2.770        4.260       1.326\r\n    ## 3  virginica        6.588       2.974        5.552       2.026\r\n\r\nEt voilà! And the result is a convenient *tibble* which is a dataframe 2.0 and you can use the same as a base dataframe.\r\n\r\nMoreover, piping makes reading code more natural, just look at the comments in the code chunk above.\r\n\r\nWhy intubate?\r\n-------------\r\n\r\nDon't think this is enough, with the `intubate` package we can go even further and pipe models as well.\r\n\r\n``` r\r\nlibrary(intubate)\r\n\r\nsummary(lm(Petal.Width ~ ., data = iris[sample(1:nrow(iris), nrow(iris) * .7), - 5]))\r\n```\r\n\r\n    ## \r\n    ## Call:\r\n    ## lm(formula = Petal.Width ~ ., data = iris[sample(1:nrow(iris), \r\n    ##     nrow(iris) * 0.7), -5])\r\n    ## \r\n    ## Residuals:\r\n    ##      Min       1Q   Median       3Q      Max \r\n    ## -0.37386 -0.12411 -0.01595  0.08865  0.54763 \r\n    ## \r\n    ## Coefficients:\r\n    ##              Estimate Std. Error t value Pr(>|t|)    \r\n    ## (Intercept)  -0.05771    0.19494  -0.296    0.768    \r\n    ## Sepal.Length -0.25555    0.05048  -5.063 1.86e-06 ***\r\n    ## Sepal.Width   0.23180    0.05419   4.277 4.30e-05 ***\r\n    ## Petal.Length  0.54363    0.02651  20.503  < 2e-16 ***\r\n    ## ---\r\n    ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\r\n    ## \r\n    ## Residual standard error: 0.1818 on 101 degrees of freedom\r\n    ## Multiple R-squared:  0.9462, Adjusted R-squared:  0.9446 \r\n    ## F-statistic: 591.7 on 3 and 101 DF,  p-value: < 2.2e-16\r\n\r\nThe *one-liner* above is a mouthful and not so clear. One way to make the same thing more clearly would be to create copies and lookup variables, but we don't like that much right?\r\n\r\n``` r\r\niris %>% # Take iris data set\r\n    select(-Species) %>% # keep all columns except Species\r\n    sample_n(nrow(iris) * .7) %>% # take a random sample of rows\r\n    ntbt_lm(Petal.Width ~ .) %>% # run a linear regression\r\n    summary # show me a summary\r\n```\r\n\r\n    ## \r\n    ## Call:\r\n    ## lm(formula = Petal.Width ~ ., data = .)\r\n    ## \r\n    ## Residuals:\r\n    ##      Min       1Q   Median       3Q      Max \r\n    ## -0.61250 -0.09824 -0.02436  0.10692  0.60443 \r\n    ## \r\n    ## Coefficients:\r\n    ##              Estimate Std. Error t value Pr(>|t|)    \r\n    ## (Intercept)  -0.25337    0.22534  -1.124 0.263506    \r\n    ## Sepal.Length -0.21542    0.05656  -3.809 0.000240 ***\r\n    ## Sepal.Width   0.23909    0.06015   3.975 0.000132 ***\r\n    ## Petal.Length  0.52827    0.02883  18.320  < 2e-16 ***\r\n    ## ---\r\n    ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\r\n    ## \r\n    ## Residual standard error: 0.1959 on 101 degrees of freedom\r\n    ## Multiple R-squared:  0.935,  Adjusted R-squared:  0.9331 \r\n    ## F-statistic: 484.2 on 3 and 101 DF,  p-value: < 2.2e-16\r\n\r\nMuch clearer and makes doing transformations before running a model feel like a breeze. If you want to use a function not included in the `intubate` package, or if you're not sure if it's implemented or not you can use it with the simple `ntbt` framework.\r\n\r\n``` r\r\niris %>% # Take iris data set\r\n    select(-Species) %>% # keep all columns except Species\r\n    sample_n(nrow(iris) * .7) %>% # take a random sample of rows\r\n    ntbt(lm, Petal.Width ~ .) %>% # run a linear regression\r\n    summary # show me a summary\r\n```\r\n\r\n    ## \r\n    ## Call:\r\n    ## lm(formula = Petal.Width ~ ., data = .)\r\n    ## \r\n    ## Residuals:\r\n    ##      Min       1Q   Median       3Q      Max \r\n    ## -0.40603 -0.10177 -0.00889  0.08524  0.60071 \r\n    ## \r\n    ## Coefficients:\r\n    ##              Estimate Std. Error t value Pr(>|t|)    \r\n    ## (Intercept)  -0.21301    0.20300  -1.049    0.297    \r\n    ## Sepal.Length -0.22614    0.05502  -4.110 8.06e-05 ***\r\n    ## Sepal.Width   0.23660    0.05713   4.142 7.17e-05 ***\r\n    ## Petal.Length  0.53710    0.02758  19.472  < 2e-16 ***\r\n    ## ---\r\n    ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\r\n    ## \r\n    ## Residual standard error: 0.1811 on 101 degrees of freedom\r\n    ## Multiple R-squared:  0.9454, Adjusted R-squared:  0.9437 \r\n    ## F-statistic: 582.4 on 3 and 101 DF,  p-value: < 2.2e-16",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}